c----------------------------------------------------------------------
      subroutine place_particles
c
c     Place particles in this routine, also called for injection
c
      include 'SIZE'
      include 'TOTAL'
      include 'CMTDATA'
      include 'CMTPART'

      real    dum

      integer icalld
      save    icalld
      data    icalld  /-1/

      real   xdrange(2,3)
      common /domainrange/ xdrange
      real   xerange(2,3,lelt)
      common /elementrange/ xerange

      real xdrange_save(2,3),rsave,rbeta,rdpe
      common /domainranges_r/ xdrange_save,rsave,rdpe,rystop,rbeta
      integer isave,isaves,Npx,Npy,Npz
      common /domainranges_i/ isave,isaves,Npx,Npy,Npz,nptot

      ! begin timer
      ptdum(3) = dnekclock()

      icalld = icalld + 1

      rpi    = 4.0*atan(1.) ! pi
      mu_0   = abs(param(2))

      if (ipart_restartr .eq. 0) then

      call move_piston(0)

c     bounds to distribute particle between
      rxbo(1,1) = xdrange(1,1) + rdpe/2.
      rxbo(2,1) = xdrange(2,1) - rdpe/2.
      rxbo(1,2) = xdrange(1,2) + rdpe/2.
      rxbo(2,2) = xdrange(2,2) - rdpe/2.
      rxbo(1,3) = xdrange(1,3) + rdpe/2.
      rxbo(2,3) = xdrange(2,3) - rdpe/2.

      vol_distrib = (rxbo(2,1)-rxbo(1,1))*(rxbo(2,2)-rxbo(1,2))*
     >              (rxbo(2,3)-rxbo(1,3))

      nxpart = 0
      nypart = 0
      nzpart = 0
      nwe    = 0

      if (nid.eq.0) then
         nxpart = Npx
         nypart = Npy
         nzpart = Npz
         nwe = nxpart*nypart*nzpart
      endif

c     main loop to distribute particles
      do kk = 1,nzpart
      do jj = 1,nypart
      do ii = 1,nxpart
         n = n + 1
         i = n
         if (n.gt.llpart)then 
            write(6,*)'Not enough space to store more particles'
            call exitt
         endif

         rxdum = rxbo(1,1) + mod(ii-1,nxpart)*rdpe
         rydum = rxbo(1,2) + mod(jj-1,nypart)*rdpe
         rzdum = rxbo(1,3) + mod(kk-1,nzpart)*rdpe

         rdum = 0.05*rdpe

         ! distribute x,y,z coordinates
         do j=0,2
            rval = unif_random(0.,1.)
            if (j.eq.0) rval = rxdum + (-rdum + 2.*rdum*rval)
            if (j.eq.1) rval = rydum + (-rdum + 2.*rdum*rval)
            if (j.eq.2) rval = rzdum + (-rdum + 2.*rdum*rval)

            rpart(jx+j,n)  = rval
            rpart(jx1+j,n) = rval
            rpart(jx2+j,n) = rval
            rpart(jx3+j,n) = rval
         enddo

c        set some rpart values for later use
         rpart(jdp,n)   = unif_random_norm(dp(1),dp(2),3.33E-3) ! particle diameter
         tau_p          = rpart(jdp,n)**2*rho_p/18.0d+0/mu_0  ! part. time scale stokes

         rpart(jtaup,n) = tau_p     ! particle time scale
         rpart(jrhop,n) = rho_p     ! material density of particle
         rpart(jvol,n)  = rpi*rpart(jdp,n)**3/6.! particle volume
         rpart(jspl,n)  = 1.        ! super particle loading
         rpart(jgam,n)  = 1.        ! initial integration correction

         rpart(jtemp,n)  = tp_0     ! intial temp as fluid air
         rpart(jtempf,n) = tp_0     ! intial temp as fluid air
         rpart(jrho,n)   = param(1) ! later overwritten by interpolation

c        set global particle id (3 part tag)
         ipart(jpid1,n) = nid 
         ipart(jpid2,n) = i
         ipart(jpid3,n) = icalld
      enddo
      enddo
      enddo

      if (nitspl.gt.0) then
         rspl = rbeta
         do i=1,n
            rpart(jspl,i) = rspl
            rpart(jdpe,i) = rdpe
         enddo
      endif

c     check if zstart and zlen is alright for a 2d case
      if (.not. if3d) then
          if (abs(zstart-1.0) .gt. 1E-16) then
             write(6,*)'***particle zstart is not right for 2d case'
             call exitt
          elseif(abs(zlen) .gt. 1E-16) then
             write(6,*)'***particle zlen is not right for 2d case'
             call exitt
         endif
      endif

c     call remove_overlap_parts

      else
         call read_parallel_restart_part
      endif

      ! end timer
      pttime(3) = pttime(3) + dnekclock() - ptdum(3)
      return
      end
c-----------------------------------------------------------------------
      subroutine usr_particles_f_user(ii,jj)
c
c     extra body forces (total force, must have mass here)
c
      include 'SIZE'
      include 'TOTAL'
      include 'CMTDATA'
      include 'CMTPART'

      real pmass,pmassf

      pmass = rpart(jvol,ii)*rpart(jrhop,ii)
      pmassf= rpart(jvol,ii)*rpart(jrho,ii)

      if (jj.eq.0) rpart(jfusr+jj,ii) = 0.0 
      if (jj.eq.1) rpart(jfusr+jj,ii) = 0.0
      if (jj.eq.2) rpart(jfusr+jj,ii) = 0.0

      if (jj.eq.1) then
         rpart(jfusr+jj,ii) = -9.8*(pmass - pmassf)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine pre_sim_collisions
c
c     time stepping routine for pre-simulation collisions/settling
c
      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'
      include 'CMTDATA'
      include 'CMTPART'

      ! NOTE WE ARE SKIPPING SINCE WE HAVE ALREADY INITIALIZED
c     goto 1234

      nmax_step = 500000  ! number of pre-iteration steps
      nmax_add  = 500001   ! quit injecting particles after this step
      ninj      = 500000      ! injection rate step

      ! pre simulation iteration for packed bed
      do i=1,nmax_step

         if (nid.eq. 0) write(6,*) 'pre-sim_io time',i,rtime,dt_cmt
         if(mod(i,iostep).eq.0) then
            call usr_particles_io
         endif

         call move_piston(i)

         do stage=1,3

            if (stage .eq. 1) then
               call set_dt_particles(rdt_part)
               dt_cmt = rdt_part
               dt     = dt_cmt
               rtime = rtime + dt_cmt
               call set_tstep_coef_part(rdt_part)

               call update_particle_location
               call move_particles_inproc

               if (two_way.gt.1) then
                  call particles_solver_nearest_neighbor
                  call spread_props_grid
               endif
            endif

            call usr_particles_forcing ! at most only qs,user,col here
            call rk3_integrate

         enddo

         if(mod(i,iostep).eq.0) then
            if (nid.eq. 0) call output_piston_plane
         endif

      enddo

 1234 continue

      return
      end
c----------------------------------------------------------------------
      subroutine remove_overlap_parts
      include 'SIZE'
      include 'TOTAL'
      include 'CMTDATA'
      include 'CMTPART'

      real    pdsit,rxwall(3)
      integer in_part(llpart)

      real   xdrange(2,3)
      common /domainrange/ xdrange

      ! first search local particles

      nlow  = n - nwe
      nhigh = n

      do j=1,n
         in_part(j) = 0
      enddo

c     let every particle search for itself
      do i = nlow,nhigh

c        particles in local elements
         do j = nlow,nhigh
            if (i .ne. j) then
               rdp1 = (6.*rpart(jspl,i)*rpart(jvol,i)/pi)**(1./3.)
               rdp2 = (6.*rpart(jspl,j)*rpart(jvol,j)/pi)**(1./3.)
               rdeff = 0.5*(rdp1 + rdp2)
               rdeff = 1.200*rdeff
               pdist = abs(rpart(jx,i)-rpart(jx,j))**2  
     >                          + abs(rpart(jy,i)-rpart(jy,j))**2
     >                          + abs(rpart(jz,i)-rpart(jz,j))**2
               pdist = sqrt(pdist)
               if (pdist .gt. rdeff) goto 1109
               ! remove here!
               in_part(i) = -1
               in_part(j) = -1
            endif
 1109        continue
         enddo

      enddo

      do i = nlow,nhigh
         do j = 1,6
            if (bc_part(j) .eq. -1) then
               nj1 = mod(j,2)
               if (nj1.ne.0) nj1 = 1
               if (nj1.eq.0) nj1 = 2
               nj2 = int((j-1)/2) + 1

               rxwall(1)   = rpart(jx  ,i)
               rxwall(2)   = rpart(jx+1,i)
               rxwall(3)   = rpart(jx+2,i)
               rxwall(nj2) = xdrange(nj1,nj2) ! wall loc

               rdp1 = (6.*rpart(jspl,i)*rpart(jvol,i)/pi)**(1./3.)
               rdeff  = rdp1
               rdeff = 1.200*rdeff
               pdist = abs(rpart(jx,i)-rxwall(1))**2  
     >                          + abs(rpart(jy,i)-rxwall(2))**2
     >                          + abs(rpart(jz,i)-rxwall(3))**2
               pdist = sqrt(pdist)
               if (pdist .gt. rdeff) goto 1108
               ! remove here!
               in_part(i) = -1
            endif
 1108 continue
         enddo
      enddo

      ic = 0
      do i=1,n
         if (in_part(i).eq.0) then
            ic = ic + 1 
            if (i .ne. ic) then
               call copy(rpart(1,ic),rpart(1,i),nr)
               call icopy(ipart(1,ic),ipart(1,i),ni)
            endif
         endif
      enddo
      n = ic

      return
      end
c----------------------------------------------------------------------
      subroutine move_piston(i)
      include 'SIZE'
      include 'TOTAL'
      include 'CMTDATA'
      include 'CMTPART'

      real   xdrange(2,3)
      common /domainrange/ xdrange

      real xdrange_save(2,3),rsave,rbeta,rdpe
      common /domainranges_r/ xdrange_save,rsave,rdpe,rystop,rbeta
      integer isave,isaves,Npx,Npy,Npz
      common /domainranges_i/ isave,isaves,Npx,Npy,Npz,nptot

      integer icalld
      save    icalld
      data    icalld  /-1/

      character*132 deathmessage

      ! /***** user set parameters *****/ ---------------------------
         rphip_assume = 0.61
         rly = 0.05 ! set in experiment or other user input
         nstep_m = 20
         nstep_w = 2000
         nstep_o = 500
      ! /***** end user set parameters *****/ -----------------------

      icalld = icalld + 1

c     First call, initialize variables to be used later -------------
      if (icalld .eq. 0) then
         rlx = xdrange(2,1) - xdrange(1,1)
         rlz = xdrange(2,3) - xdrange(1,3)
         
         RYL = xdrange(1,2)
         rdp   = dp(1) ! should be same as dp(2) because monodisperse
         rVp   = pi/6.*rdp**3
         rbeta = rphip_assume*rlx*rly*rlz/(nw*rVp) ! spl
         
         rdpe = rbeta**(1./3.)*rdp
         rlamb = rdpe
         
         Npx = floor(rlx/rlamb)
         Npz = floor(rlz/rlamb)
         Npy = nw/Npx/Npz
         nptot = Npx*Npy*Npz
         
         ryset = RYL + rlamb*Npy
         
         if (abs(xdrange(2,2) - ryset) .gt. 1E-6) then
               deathmessage =  
     >           'WARNING: SET box height to:'
               if (nid.eq. 0)write(6,*) deathmessage,ryset
               call exittr(deathmessage,ryset,i)
         endif
         
         rystop = RYL + rbeta*rVp*nptot/(rphip_assume*rlx*rlz)
         
         isave = 0
         
         do jj=1,3
         do ii=1,2
            xdrange_save(ii,jj) = xdrange(ii,jj)
         enddo
         enddo
      endif

c     After first call, move the pistion if needed ------------------
      if (icalld .gt. 0) then

      if (mod(i,nstep_m) .eq. 0) then
         ! MOVING DOWN PISTOn
         if (isave .eq. 0) then
         if (xdrange(2,2) .lt. rystop) then
            rsave = xdrange(2,2) + rdpe/4.
            isave = 1
            isaves = i
         endif
            xdrange(2,2) = xdrange(2,2) - rdpe/8.
         endif

         ! OSCILATION PISTOn
         if (isave .eq.1) then
         if (i .lt. isaves + nstepw) then
            xdrange(2,2) = rsave + 
     >               1.0*rdpe*cos(2.*pi*mod(i,nstep_o)/real(nstep_o))
         else
            isaves = i
            isave = 2
            xdrange(2,2) = rsave + 3.*rdpe
         endif
         endif

         ! REMOVE PISTOn
         if (isave .eq. 2) then
            if (i .lt. isaves + nstep_w) then
               xdrange(2,2) = xdrange_save(2,2)
               do ii = 1,n
                  do jj=0,2
                     rpart(jv0+jj,ii) = 0.
                     rpart(jv1+jj,ii) = 0.
                     rpart(jv2+jj,ii) = 0.
                     rpart(jv3+jj,ii) = 0.
                  enddo
               enddo
               isave = 3
            endif
         endif
      endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine output_piston_plane
      include 'SIZE'
      include 'TOTAL'
      include 'CMTDATA'
      include 'CMTPART'

      real   xdrange(2,3)
      common /domainrange/ xdrange

      !NOTE THIS IS NOT GENERAL... OUTPUT Y_UP ONLY!

      character*15 fnamec,fnamen

      integer icalld
      save    icalld
      data    icalld  /-1/


      icalld = icalld + 1

      write(fnamec,'(A6,I5.5,A4)') 'grid_c', icalld, '.vtk'
      open(unit=72,file=fnamec)

      write(72,'(A26)') '# vtk DataFile Version 3.0'
      write(72,'(A14)') '3D scalar data'
      write(72,'(A5)') 'ASCII'
      write(72,*) 'DATASET UNSTRUCTURED_GRID'

      write(72,'(A7,I0,A6)') 'POINTS ', 4,' float'
      write(72,'(F0.5,A1,F0.5,A1,F0.5)') xdrange(1,1),' ',xdrange(2,2),
     >                                                ' ',xdrange(1,3)
      write(72,'(F0.5,A1,F0.5,A1,F0.5)') xdrange(1,1),' ',xdrange(2,2),
     >                                                ' ',xdrange(2,3)
      write(72,'(F0.5,A1,F0.5,A1,F0.5)') xdrange(2,1),' ',xdrange(2,2),
     >                                                ' ',xdrange(1,3)
      write(72,'(F0.5,A1,F0.5,A1,F0.5)') xdrange(2,1),' ',xdrange(2,2),
     >                                                ' ',xdrange(2,3)
      write(72,*) ''

      write(72,'(A6,I0,A1,I0)') 'CELLS ', 1, ' ', 5
      write(72,'(I0,A1,I0,A1,I0,A1,I0,A1,I0)') 
     >        4,' ',0,' ',1,' ',2,' ',3
      write(72,*) ''

      write(72,'(A11,I0)') 'CELL_TYPES ', 1
      write(72,'(I0)') 9
      write(72,*) ''

      write(72,*) 'CELL_DATA',1
      write(72,*) 'SCALARS  dumdata  float 1'
      write(72,*) 'LOOKUP_TABLE default'
      write(72,*) 0.
      write(72,*) ''

      close(72)
      


      return
      end
c----------------------------------------------------------------------
